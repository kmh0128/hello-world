정렬
======
정렬이란 데이터를 특정한 기준에 의해서 순서대로 나열하는 것입니다.
-------------------------------------------------------------------
선택 정렬(Selection Sort)
삽입 정렬(Insertion Sort)
버블 정렬(bubble sort)
기본 알고리즘 3종 (선택/버블/삽입)이 있습니다.

# 선택 정렬
![다운로드 (1)](https://user-images.githubusercontent.com/100178951/157256165-6425b081-e704-44b6-9a69-063e8029586d.png)
선택정렬은 가장 작은 수를 찾아내서 앞으로 보내서 정렬시키는 정렬입니다.
배열의 처음부터 끝까지 탐색하여 가장 작은수를 앞으로 보내고 또 가장 앞에 있는수 다음으로 가장 작은수를 또 찾아내서 앞으로보내는 작업을 반복합니다.
선택 정렬의 시간 복잡도는 배열의 길이 n을 n회 2중 반복문을 돌아야 하기 때문에 n^2, O(n^2)이라고 표기합니다.

# 버블 정렬
![다운로드 (2)](https://user-images.githubusercontent.com/100178951/157257039-a558c8c5-991c-4357-8100-411591f0a58d.png)

버블 정렬은 두개의 인접한 값을 비교하면서 정렬하는 방식이며 Bubble sort는 원소의 이동이 거품이 수면위로 올라오는 것 같다고 해서 붙여진 이름이다.
버블 정렬은 데이터를 말그래도 비교하면서 정렬하는 방식이라 추가적인 공간이 필요하지않으면 제자리 정렬(in-place sort)입니다.
정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하지만 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다. 
 ## 정렬 방법
1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교
2. 현재 원소가 다음 원소보다 크면 원소를 교환
3. 다음 원소로 이동하여 해당 원소와 그 다음원소를 비교
각 회전을 진행할때마다 뒤에서 비교되어서 정렬되어져서 갈수록 비교하는 횟수가 적어지는것도 특징이다.
장점들이 메모리소비가 적고 구현이 쉽고 안정적이지만 동시에 단점은 다른 알고리즘에비해 교환비교하는횟수가 많아서 시간이 많이 소모가됩니다.
시간복잡도는 O(N2)이다

# 삽입 정렬
![다운로드 (3)](https://user-images.githubusercontent.com/100178951/157257858-d84c819b-db58-4bb2-b48c-943d38f8126a.png)
삽입 정렬은 현재 비교하고자하는 대상으로 삼은 원소(타겟(target))과과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법입니다.
삽입 정렬은 데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지않습니다.
이때문에 '제자리 정렬(in-place sort)'이기도 하다.
정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다. 
이는 선택정렬과도 같은 부분이다.
그리고 이전에 다뤘던 선택 정렬과는 달리 삽입 정렬은 '안정 정렬'이다.

## 정렬 방법
1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. (첫 번째 타겟은 두 번째 원소부터 시작)
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환
3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복
4. 첫 번째 원소가 타겟이 되어도 비교가 안되기때문에 2번째 원소부터 시작합니다.

합병 정렬(Merge sort)
==========
합병 정렬은 분할정복(Divide and conquer)방식으로 설계된 알고리즘이다. 방식은 한가지의 큰문제를 반으로 쪼개서 해결하는 방식이다.
분할의 배열이 1보다 작아질때 까지 반복한다.

참고자료-https://st-lab.tistory.com/179?category=892973
         https://kim-oriental.tistory.com/15
